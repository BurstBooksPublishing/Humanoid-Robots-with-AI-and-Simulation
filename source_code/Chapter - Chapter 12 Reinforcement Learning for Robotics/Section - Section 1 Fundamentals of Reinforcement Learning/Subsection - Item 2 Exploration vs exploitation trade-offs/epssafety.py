class EpsilonGreedySafe:
    def __init__(self, policy, env, eps_start=0.5, eps_min=0.05, decay=1e-4):
        self.policy = policy              # deterministic policy object
        self.env = env                    # gym-like environment
        self.eps = eps_start
        self.eps_min = eps_min
        self.decay = decay
    def step(self, state, step_count):
        # anneal epsilon
        self.eps = max(self.eps_min, self.eps * (1.0 - self.decay))
        if np.random.rand() < self.eps:
            # exploration: sample within joint limits
            a = self.env.action_space.sample()    # random, safe by design
        else:
            a = self.policy.act(state)            # exploit policy
        a_safe = self._safety_projection(a, state)  # enforce torques, stability
        return a_safe
    def _safety_projection(self, a, state):
        # simple projection: clip to joint bounds and limit torque rate
        a = np.clip(a, self.env.action_space.low, self.env.action_space.high)
        # additional heuristic: scale down actions if estimated ZMP unstable
        if self._predict_instability(state, a):
            a = 0.5 * a   # conservative fallback scaling
        return a
    def _predict_instability(self, state, a):
        # placeholder: evaluate center-of-pressure or ZMP predictor
        zmp = self.env.zmp_model.predict(state, a)
        return not self.env.zmp_model.is_within_support(zmp)